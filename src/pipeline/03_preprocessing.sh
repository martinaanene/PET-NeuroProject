#!/bin/bash
# Preprocessing Script (SPM Based - Standard PiB Method)
# Based on Centiloid Project Guidelines
# Uses SPM12 (Neurodesk standard) to replicate SPM8 "Unified Segmentation" workflow.

set -e

# Check for Subject ID argument
if [ -z "$1" ]; then
    echo "Usage: $0 <subject_id>"
    echo "Example: $0 02"
    exit 1
fi

subject_id=$1
subject="sub-${subject_id}"

echo "Preprocessing Subject: ${subject} (SPM Based)"

# --- Step 1: Frame Averaging (Using FSL tools for efficiency) ---
# SPM doesn't have a simple CLI for this, so we use FSL to prepare the static image.
if ! ml fsl/6.0.7.8 2>/dev/null; then
    ml fsl
fi

# Load SPM12 (Confirmed version)
if ! ml spm12/r7771 2>/dev/null; then
    echo "Specific SPM12 module not found, trying default..."
    ml spm12
else
    echo "Loaded SPM12/r7771 module."
fi

# Determine the directory where this script is located
SCRIPT_DIR="$( cd "$( dirname "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )"
PROJECT_ROOT="$(dirname "$(dirname "$SCRIPT_DIR")")"

cd ~/Desktop/derivatives/data/${subject}/pet/
pet_dir=$(pwd)

# --- CLEANUP START: Remove old intermediate files ---
# This ensures that if the script fails, we don't accidentally use old files.
rm -f "realign_job.m" "sw${subject}_pet_avg.nii" "w${subject}_pet_avg.nii" "${subject}_pet_to_MNI_smoothed.nii.gz"
echo "Removed old intermediate files."


# Path to the CSV file
FRAMING_CSV="${PROJECT_ROOT}/data/references/framing_info.csv"
frame_info=$(grep "AD${subject_id}," "$FRAMING_CSV")
range=$(echo "$frame_info" | cut -d',' -f3)
start_frame=$(echo "$range" | cut -d'-' -f1)
end_frame=$(echo "$range" | cut -d'-' -f2)

start_idx=$((start_frame - 1))
num_frames=$((end_frame - start_frame + 1))

# --- Step 1: Motion Correction (SPM Realignment) ---
# ---------------------------------------------------------------------------------
# Instead of simple averaging, we use SPM Realignment for Motion Correction

# 1a. Extract frames for realignment
echo "Extracting frames for realignment..."
mkdir -p "frames"
# Convert 4D NIfTI to separate 3D NIfTIs
# Use fslsplit. Output prefix: vol_
fslsplit "${subject}_pet.nii.gz" "frames/vol_"

# Get list of frames (absolute paths)
frame_list=""
# Note: fslsplit numbers them vol_0000.nii.gz, vol_0001.nii.gz
for ((i=start_frame; i<=end_frame; i++)); do
    padded_num=$(printf "%04d" $i)
    # Gunzip them for SPM compatibility
    gunzip -f "frames/vol_${padded_num}.nii.gz"
    frame_list="$frame_list '$(pwd)/frames/vol_${padded_num}.nii',"
done

# Remove trailing comma
frame_list="${frame_list%,}"

# 1b. Generate Self-Contained SPM Realignment Job
# We construct the MATLAB script content directly here.
# This ensures compatibility with Standalone SPM (which doesn't support 'inputs' injection easily).

echo "Generating SPM Realignment Job..."
job_file="${pet_dir}/realign_job.m"

# Prepare the file list formatted for MATLAB: {'path/to/file1,1'; 'path/to/file2,1'; ...}
# Note: frames are in $pet_dir/frames
files_matlab=""
# Loop through sorted files to ensure correct order
for f in $(ls "${pet_dir}/frames"/vol_*.nii | sort); do
    files_matlab="${files_matlab}'${f},1';"$'\n'
done

cat <<EOF > "$job_file"
% SPM Realignment Job (Generated by SHELL)
spm('defaults', 'PET');
spm_jobman('initcfg');

matlabbatch{1}.spm.spatial.realign.estwrite.data = {
    {
$files_matlab
    }
}';
matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.quality = 0.9;
matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.sep = 4;
matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.fwhm = 5;
matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.rtm = 1;
matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.interp = 2;
matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.wrap = [0 0 0];
matlabbatch{1}.spm.spatial.realign.estwrite.eoptions.weight = '';
matlabbatch{1}.spm.spatial.realign.estwrite.roptions.which = [2 1];
matlabbatch{1}.spm.spatial.realign.estwrite.roptions.interp = 4;
matlabbatch{1}.spm.spatial.realign.estwrite.roptions.wrap = [0 0 0];
matlabbatch{1}.spm.spatial.realign.estwrite.roptions.mask = 0;
matlabbatch{1}.spm.spatial.realign.estwrite.roptions.prefix = 'r';

spm_jobman('run', matlabbatch);
exit;
EOF

# 1c. Run SPM Realignment
echo "Running SPM Batch..."
if command -v spm12 &> /dev/null; then
    # Neurodesk Standalone
    spm12 batch "$job_file"
elif command -v matlab &> /dev/null; then
    # Standard MATLAB
    matlab -nodisplay -nosplash -nodesktop -r "run('$job_file');"
else
    echo "ERROR: Neither spm12 nor matlab command found."
    exit 1
fi

# 1d. Define the new 'Mean PET' for downstream analysis
# SPM (with 'mean image' option enabled) creates 'meanvol_0000.nii' in input dir
echo "Locating Mean Realigned Image..."
mean_realigned_image=$(find "${pet_dir}/frames" -name "meanvol_*.nii" | head -n 1)

if [ -z "$mean_realigned_image" ]; then
    echo "ERROR: Mean realigned image not found. Motion correction failed."
    exit 1
fi

echo "Motion Correction Complete."
echo "Mean Realigned Image: $mean_realigned_image"

# Move and rename for consistency (so the rest of the script works as is)
mv "$mean_realigned_image" "${subject}_pet_avg.nii"
# Also clean up the 'frames' folder to save space
rm -rf "frames" "$runner_script"

# Reorient for consistency with standard space
# Reorient for consistency with standard space
# Note: FSL usually outputs .nii.gz (NIFTI_GZ) by default. We handle that explicitly.
fslreorient2std "${subject}_pet_avg.nii" "${subject}_pet_avg_reoriented.nii.gz"
mv "${subject}_pet_avg_reoriented.nii.gz" "${subject}_pet_avg.nii.gz"
gunzip -f "${subject}_pet_avg.nii.gz"

# Skip the old averaging logic
# fslroi ${subject}_pet.nii.gz ${subject}_pet_crop.nii.gz $start_idx $num_frames
# fslmaths ${subject}_pet_crop.nii.gz -Tmean ${subject}_pet_avg.nii.gz
# Reorient for consistency with standard space
fslreorient2std ${subject}_pet_avg.nii.gz ${subject}_pet_avg_reoriented.nii.gz
mv ${subject}_pet_avg_reoriented.nii.gz ${subject}_pet_avg.nii.gz
# Unzip for SPM (SPM often prefers .nii)
gunzip -f ${subject}_pet_avg.nii.gz

# Prepare MRI
# Prepare MRI
cd ~/Desktop/derivatives/data/${subject}/anat/
cp ${subject}_T1w.nii.gz ${subject}_T1w_preproc.nii.gz

# Reorient the copy for consistency
# Yields T1w_preproc.reorient.nii.gz
fslreorient2std ${subject}_T1w_preproc.nii.gz ${subject}_T1w_preproc.reorient.nii.gz

# Rename to final T1w.reoriented.nii.gz
mv ${subject}_T1w_preproc.reorient.nii.gz ${subject}_T1w.reoriented.nii.gz

# Prepare for SPM (requires .nii)
gunzip -f ${subject}_T1w.reoriented.nii.gz

# --- Step 2: Generate SPM Batch Script ---
cd ~/Desktop/derivatives/data/${subject}/

# Define paths
# Define paths
mri_file="$(pwd)/anat/${subject}_T1w.reoriented.nii"
pet_file="$(pwd)/pet/${subject}_pet_avg.nii"
spm_script="spm_preprocessing_job.m"

cat > "$spm_script" <<EOF
% SPM Batch Script for Centiloid Preprocessing
% Generated by 03_preprocessing_spm_based.sh

spm('defaults', 'FMRI');
spm_jobman('initcfg');

% --- Auto-Reorient: Reset Origin to Center of Image ---
% Approximates manual AC-PC alignment by centering the origin
files_to_reorient = {'$mri_file', '$pet_file'};
for i = 1:numel(files_to_reorient)
    fname = files_to_reorient{i};
    v = spm_vol(fname);
    M = v.mat;
    % Calculate geometric center of volume in voxels
    com = (v.dim(1:3)' + 1) / 2;
    % We want this voxel coordinate to be (0,0,0) mm
    % M_new * [com; 1] = [0; 0; 0; 1]
    % [R T] * [com; 1] = 0  =>  R*com + T = 0  =>  T = -R*com
    R = M(1:3, 1:3);
    T_new = -R * com;
    M_new = [R T_new; 0 0 0 1];
    spm_get_space(fname, M_new);
end

matlabbatch = {};

% 1. Coregister: Estimate (Reference: MRI, Source: PET)
matlabbatch{1}.spm.spatial.coreg.estimate.ref = {'$mri_file,1'};
matlabbatch{1}.spm.spatial.coreg.estimate.source = {'$pet_file,1'};
matlabbatch{1}.spm.spatial.coreg.estimate.other = {''};
matlabbatch{1}.spm.spatial.coreg.estimate.eoptions.cost_fun = 'nmi';
matlabbatch{1}.spm.spatial.coreg.estimate.eoptions.sep = [4 2];
matlabbatch{1}.spm.spatial.coreg.estimate.eoptions.tol = [0.02 0.02 0.02 0.001 0.001 0.001 0.01 0.01 0.01 0.001 0.001 0.001];
matlabbatch{1}.spm.spatial.coreg.estimate.eoptions.fwhm = [7 7];

% 2. Segment (Unified Segmentation)
% This generates the forward deformation field (y_*.nii)
matlabbatch{2}.spm.spatial.preproc.channel.vols = {'$mri_file,1'};
matlabbatch{2}.spm.spatial.preproc.channel.biasreg = 0.001;
matlabbatch{2}.spm.spatial.preproc.channel.biasfwhm = 60;
matlabbatch{2}.spm.spatial.preproc.channel.write = [0 1]; % Save Bias Corrected
matlabbatch{2}.spm.spatial.preproc.tissue(1).tpm = {fullfile(spm('Dir'),'tpm','TPM.nii,1')};
matlabbatch{2}.spm.spatial.preproc.tissue(1).ngaus = 1;
matlabbatch{2}.spm.spatial.preproc.tissue(1).native = [1 0];
matlabbatch{2}.spm.spatial.preproc.tissue(1).warped = [0 0];
matlabbatch{2}.spm.spatial.preproc.tissue(2).tpm = {fullfile(spm('Dir'),'tpm','TPM.nii,2')};
matlabbatch{2}.spm.spatial.preproc.tissue(2).ngaus = 1;
matlabbatch{2}.spm.spatial.preproc.tissue(2).native = [1 0];
matlabbatch{2}.spm.spatial.preproc.tissue(2).warped = [0 0];
matlabbatch{2}.spm.spatial.preproc.tissue(3).tpm = {fullfile(spm('Dir'),'tpm','TPM.nii,3')};
matlabbatch{2}.spm.spatial.preproc.tissue(3).ngaus = 2;
matlabbatch{2}.spm.spatial.preproc.tissue(3).native = [1 0];
matlabbatch{2}.spm.spatial.preproc.tissue(3).warped = [0 0];
matlabbatch{2}.spm.spatial.preproc.tissue(4).tpm = {fullfile(spm('Dir'),'tpm','TPM.nii,4')};
matlabbatch{2}.spm.spatial.preproc.tissue(4).ngaus = 3;
matlabbatch{2}.spm.spatial.preproc.tissue(4).native = [1 0];
matlabbatch{2}.spm.spatial.preproc.tissue(4).warped = [0 0];
matlabbatch{2}.spm.spatial.preproc.tissue(5).tpm = {fullfile(spm('Dir'),'tpm','TPM.nii,5')};
matlabbatch{2}.spm.spatial.preproc.tissue(5).ngaus = 4;
matlabbatch{2}.spm.spatial.preproc.tissue(5).native = [1 0];
matlabbatch{2}.spm.spatial.preproc.tissue(5).warped = [0 0];
matlabbatch{2}.spm.spatial.preproc.tissue(6).tpm = {fullfile(spm('Dir'),'tpm','TPM.nii,6')};
matlabbatch{2}.spm.spatial.preproc.tissue(6).ngaus = 2;
matlabbatch{2}.spm.spatial.preproc.tissue(6).native = [0 0];
matlabbatch{2}.spm.spatial.preproc.tissue(6).warped = [0 0];
matlabbatch{2}.spm.spatial.preproc.warp.mrf = 1;
matlabbatch{2}.spm.spatial.preproc.warp.cleanup = 1;
matlabbatch{2}.spm.spatial.preproc.warp.reg = [0 0.001 0.5 0.05 0.2];
matlabbatch{2}.spm.spatial.preproc.warp.affreg = 'mni';
matlabbatch{2}.spm.spatial.preproc.warp.fwhm = 0;
matlabbatch{2}.spm.spatial.preproc.warp.samp = 3;
matlabbatch{2}.spm.spatial.preproc.warp.write = [1 1]; % Write Deformation Fields

% 3. Normalise: Write (Apply to PET)
matlabbatch{3}.spm.spatial.normalise.write.subj.def(1) = cfg_dep('Segment: Forward Deformations', substruct('.','val', '{}',{2}, '.','val', '{}',{1}, '.','val', '{}',{1}), substruct('.','fordef', '()',{':'}));
matlabbatch{3}.spm.spatial.normalise.write.subj.resample = {'$pet_file,1'};
matlabbatch{3}.spm.spatial.normalise.write.woptions.bb = [-90 -126 -72; 91 91 109];
matlabbatch{3}.spm.spatial.normalise.write.woptions.vox = [2 2 2]; % 2mm isotropic
matlabbatch{3}.spm.spatial.normalise.write.woptions.interp = 4;
matlabbatch{3}.spm.spatial.normalise.write.woptions.prefix = 'w';

% 4. Smooth (8mm FWHM)
matlabbatch{4}.spm.spatial.smooth.data(1) = cfg_dep('Normalise: Write: Resampled Images (Subj 1)', substruct('.','val', '{}',{3}, '.','val', '{}',{1}, '.','val', '{}',{1}, '.','val', '{}',{1}), substruct('()',{1}, '.','files'));
matlabbatch{4}.spm.spatial.smooth.fwhm = [8 8 8];
matlabbatch{4}.spm.spatial.smooth.dtype = 0;
matlabbatch{4}.spm.spatial.smooth.im = 0;
matlabbatch{4}.spm.spatial.smooth.prefix = 's';


EOF

# --- Step 3: Run SPM ---
echo "Running SPM Batch..."
# Try running via standalone SPM or MATLAB
if command -v matlab &> /dev/null; then
    matlab -nodisplay -nosplash -nodesktop -r "run('$spm_script'); exit"
elif command -v spm12 &> /dev/null; then
    # Neurodesk specific command might vary, assuming spm12 script execution
    spm12 batch "$spm_script"
else
    echo "WARNING: Neither MATLAB nor SPM12 command found. The batch script '$spm_script' has been generated but not run."
    echo "Please run it manually in your SPM environment."
fi

# --- Step 4: Final Cleanup ---
# Rename output to match pipeline expectation if successful
if [ -f "pet/sw${subject}_pet_avg.nii" ]; then
    gzip -c "pet/sw${subject}_pet_avg.nii" > "pet/${subject}_pet_to_MNI_smoothed.nii.gz"
    echo "SPM Processing Complete. Output: pet/${subject}_pet_to_MNI_smoothed.nii.gz"
    
    # ---------------------------------------------------------
    # NEW: Aggressive Cleanup to prevent Disk Full errors
    # ---------------------------------------------------------
    echo "Cleaning up intermediate files..."
    
    # Remove SPM output NIfTIs (sw*.nii is already gzipped above)
    rm -f "pet/sw${subject}_pet_avg.nii" "pet/w${subject}_pet_avg.nii" "anat/y_${subject}_T1w.reoriented.nii"
    
    # Remove intermediate FSL files
    rm -f "pet/${subject}_pet_crop.nii.gz" "pet/${subject}_pet_avg.nii.gz" "anat/${subject}_T1w_preproc.nii.gz"
    
    echo "Cleanup complete."
fi

echo "SPM Based Preprocessing Script Finished."
